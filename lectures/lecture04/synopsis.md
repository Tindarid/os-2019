-> Литература <-
===============

# Что читать?
  * Understanding the Linux Kernel by Daniel P. Bovet & Marco Cesati
  * Intel 64 and IA-32 Architectures Software Developer''s Manual Volume 3
  * x86 Instruction Set Architecture by Tom Shanley
  * What every programmer should know about memory by Ulrich Drepper
  * Безопасное программирование на C и C++. Роберт С. Сиакорд

---

-> Сегодня <-
  * Память
  * Физическая и виртуальная адресация
  * Немного о прерываниях и исключениях
  * Виртуальная память
    - Сегментная организация
    - Страничная организация
  * MMU
  * Переключение контекста
  * Применение
  * Производительность
  * Безопасность

---

-> Прерывания и исключения <-
=============================

 * Interrupt Descriptor Table
    - Таблица функций
    - Фиксированный адрес в памяти или регистр(IDTR)
    - Division by zero
    - General Protection Fault
    - Page fault
    - etc.
 * Вызов обработчика ситуации процессором
 * arch/x86/entry/entry_32.S

---

-> Память <-
============
  * Память как массив
  * Проблемы
    - Памяти мало, она дорогая
      * Есть больший по объему и менее дорогой жесткий диск - можно ли использовать его?
    - Памяти мало, программ много, как договориться?
      * Working set процесса маленький(80/20) - для работы памяти нужно немного
      * Выгружать неиспользуемую память на диск
      * Суммарное потребление памяти всеми процессами может быть заведомо больше доступной памяти
      * Хочется уметь переиспользовать память
    - Памяти мало, программ много, как защититься?
      * Память для чтения от записи?
      * Память для записи от исполнения?
      * Одни процессы от других(баг в одном процессе повреждает другие процессы)
      * [K] от [U]

---

-> Подход № 1 <-
================
Досегментная организация

 Попробуем изменять адреса в программе перед ее запуском?
  * Выделить необходимое количество памяти программе
  * Заменить в ней все адреса с учетом выделенного куска памяти
  * Relocations

Проблемы:
  * А что если понадобилось переместить программу в памяти?
  * Проблема сегментации - не нашли куска подходящего размера
  * Защиты нет

---

-> Подход № 2 <-
================
Сегментная организация

Введем косвенность:
  * Программы работают с виртуальными адресами
  * Виртуальный адрес = смещение относительно сегмента
  * Сегмент = база + размер
  * Физический адрес = база сегмента + виртуальный адрес
  * Преобразование виртуального адреса в физический выполняет MMU(Memory Managment Unit)
  * MMU управляется из привилегированного режима
  * Перемещение памяти программы: изменение базы сегмента
  * Переключение выполняемой программы: заменить поток выполнения + заменить сегмент
  * Память per process
  * Relocations все еще нужны
![Segment-translation]
(https://github.com/ubique/os-lectures/virtual-memory-segment-translation.png)

---

-> Сегментная организация <-
============================

Что хорошего?
  * Быстро работает - трансляция виртуального адреса в физический - сложение, простое железо

А плохого?
  * Сегмент имеет ограниченный размер - что если понадобилось больше памяти?
  * Не возможно переиспользования памяти
  * Несколько сегментов. x86 case study: ds, ss, cs, general purpose
    - Добавляем права на сегменты
    - Накладывает ограничения на модель работы
    - Можно шарить память: сегменты кода или данных для чтения разных процессов одного исполняемого файла
      имеют одинаковую базу и размер
    - Усложнение логики MMU
  * Фрагментация: внешняя и внутренняя

---

-> Подход № 3 <-
================

Страничная организация

Как бороться с внешней фрагментацией?
  * Нарежем все на кусочки - страницы(common case 4KB)
  * Размер страницы - tradeoff внутрення фрагментация и overhead
  * Нужно уметь отображать виртуальный адрес страницы на физический - MMU
  * Ядро должно перехватывать ошибки обращений к страницам
    - write to read only
    - execute non executable
  * Ядро должно уметь изменять отображение виртуальных страниц в физические

Тогда:
  * Нет внешней фрагментации
  * Внутренняя фрагментация - half of page size
  * Упрощается выделение памяти - нужно найти не линейный кусок, а можно страницами
  * Можно выгружать страницы памяти на диск
  * Права можно задавать для каждой страницы отдельно
  * Виртуальный адрес = номер страницы + смещение в странице
  * Трансляция виртуального адреса - трансляция адреса страницы + смещение в странице
  * Процессу нужна таблица страниц
  * Картинка трансляции

---

-> Страничная организация в x86 <-
============================
  * Таблица страниц - много места. Нужна иерархия.
  * Размер иерархии - tradeoff между overhead на размер служебной информации и скоростью трансляции
  * Иерарахия:
    - page directory = 1024 page directory entry
      * PDE содержит адрес page table(PT)
    - PT - 1024 page table entry(PTE)
      * PTE содержит физический адрес страницы
      * PT - 4 MB of Virtual Memory
  * control register %cr3 - физический адрес page directory
  * В x86 одновременно есть и сегментация организация - база в 0, размер на всю память
  * x86-64 - 4 уровня косвенности
  * Картинки

---

-> MMU <-
============================
  * Трансляция выполняется аппаратно с помощью MMU
  * Несколько обращений к памяти
  * Проверка прав доступа
  * Генерация прерываний при ошибках
  * Медленно - TLB(Translation Lookaside Buffer)
    - Очень быстрый => очень дорогой => очень маленький
    - Виртуальный адрес в физический
    - Права доступа
    - Инвалидация - следит ядро
    - Картинка


---

-> Переключение контекста <-
============================
  * Восстановить память процесса(%cr3)
  * Восстановить поток выполнения: значения регистров
  * Память ядра - защищаемся привилегиями
    - Картинка

---

-> Page fault <-
================
  * Проверка PD, PT, PTE, прав доступа
  * MMU генерирует прерывание - адрес и тип доступа
  * ISR в ядре

---

-> Примеры использования <-
============================
  * Подкачка по требованию
  * Copy On Write
  * Swap
  * Рост стэка
  * Разделяемый текст => Разделяемые библиотеки
  * Разделяемая память
  * Картинки

-> Page Reclaiming <-
=====================
  * Идеальный - нужно освободить ту страницу, которая дольше всего не потребуется
  * Belady Anomaly
    - FIFO
    - Reference string: 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5
    - 3 phys pages: 9 page faults
    - 4 phys pages: 10 page faults
  * LRU
  * Clock algorithm - aproximiate LRU

---

-> Производительность <-
============================
  * Память это дорого
  * case study - vk udp sessions
  * Чем меньше памяти используется, тем лучше

-> Запрос памяти у ядра <-
==========================
  * Системные вызовы: brk, sbrk, mmap,  munmap
  * malloc/free, new/delete: userspace аллокаторы
  * userspace аллокатор использует выделенную ядром память для запросов

---

-> Безопасность <-
============================
  * Переполнение буфферов
  * Meltdown
  * ASLR

---
