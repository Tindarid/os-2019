\documentclass[../../lectures.tex]{subfiles}

\begin{document}
\chapter{Виртуальная память}

\section{Прерывания и исключения}
\begin{itemize}
    \item Процессор с памятью не могут быть жить в вакууме (без ОС)
    \item Простыми словами: иногда процессор не знает что ему делать 
          в конкретной ситуации, так как не знает контекста исполнения, 
          тогда он просит помощи у внешней среды (чаще всего ОС)
    \item \emph{Interrupt Deriving Architecture} --- есть таблица, каждой ячейке 
          которой соотвествует какая-либо исключительная ситуация(например, 
          поделить на нуль) и функция ее разрешающая.
    \item \textbf{IDTR} --- регистр, в котором хранится адрес 
          \emph{Interrupt Descriptor Table} (глобальный)

          В некоторых архитектурах находится по фиксированному адресу 
          (например, x86 --- защищенный режим)

          Проще говоря \textbf{callbacks}

    \item Другой подход --- \emph{Polling} (есть управляющий код, 
          который периодически опрашивает устройство на предмет того,
          что нужно обработать; процессор выставляет флаг --- 
          "нуждаюсь в обработке"). 
          
          Пример --- сетевая карта

    \item У каждого подхода свои плюсы и минусы

    \item \textbf{cr2} --- контрольный регистр, считывается функцией \emph{do\_page\_fault} 
          (которая занимается обработкой \textbf{page fault})
\end{itemize}

\newpage
\section{Память}
Хочется чтобы каждый процесс был защищен от любого другого

Проблемы памяти:
\begin{enumerate}
    \item Памяти мало, она дорогая
    \item Памяти мало, программ много, как договориться?

          Закон Парето - 80\% обращений к 20\% памяти в среднем у пользовательской программы

          Может тогда выгружать неиспользуемую память на диск?

          Может еще переиспользовать память? (например, сегмент \textbf{text} у \textbf{Chrome})
    \item Памяти мало, программ много, как защититься?

          Неплохо было бы выложить в read-only какую-то память 
          (сегмент \textbf{text} --- \emph{const}-переменные)

          \code{stackoverflow.cpp}{C++}

          Способ защиты --- память, которая может записываться не может выполняться

          Канарейка на стеке --- проверяем значение переменной 'канарейка', которую добавили после адреса возврата

          Хотим чтобы память ядра была недоступна пользователям
\end{enumerate}
Как можно это все сделать?

\newpage
\section{Подходы к организации памяти}
\todo{}
\subsection{Досегментная организация(№1)}
\subsection{Сегментная организация(№2)}
\subsection{Страничная организация(№3)}
\subsection{Страничная организация в x86(Реальность)}

\section{MMU}
\todo{}

\section{Переключение контекста}
\todo{}

\section{Примеры использования}
\subsection{Подкачка по требованию}
\begin{itemize}
    \item Пусть у нас есть фильм. Давайте читать этот файл используя
          окно считывания. Прикольно. Но можем замаппить файл в память 
          и читать его.
    \item Каждый раз когда читаем еще незагруженную страницу, \textbf{page fault},
          далее ядро подгружает страницу.
    \item Еще пример --- \shell{chrome \-\-help} (нам незачем инициализировать всю работу приложения)
    \item Ядро достаточно оптимально все это делает.
\end{itemize}
\subsection{Copy on write}
\code{copyonwrite.cpp}{C++}
Какое значение x будет в parent и в child?

Немного по-другому
\code{copyonwrite2.cpp}{C++}
\begin{itemize}
    \item Одинаковые адреса, значение разное (child --- 43, parent --- 42)
    \item При создании процесса --- ничего не делаем
    \item За всей этой истории стоит \textbf{MMU}
\end{itemize}

\subsection{Swap}
\begin{itemize}
    \item Скидывание на диск холодной data
    \item \textbf{MMU} ходит по кругу и проверяет использование страниц
\end{itemize}

\subsection{Другие}
\begin{itemize}
    \item Рост стека
    \item Разделяемый текст => Разделяемые библиотеки
    \item Разделяемая память
\end{itemize}

\section{Выделение памяти}
\subsection{Пример №1}
\code{mem1.c}{C}
\shell{cc mem1.c -o mem1}

\shell{strace -f ./mem1}
\code{mem1.trace}{C}

\begin{itemize}
    \item Нет никакого выделения памяти через \emph{malloc} (потому что это не системный вызов)
    \item \shell{man 2 brk, sbrk} --- явное увеличение/уменьшение кучи
    \item Для того же самого со стеком системных вызовов нет (только ассемблерные инструкции)
\end{itemize}

\subsection{Syscalls}
\begin{itemize}
    \item \emph{malloc/calloc/realloc} через прослойку выделяют себе блок памяти, режут его на куски и выдают клиенту-программисту
    \item \emph{free()} --- отдает блок памяти не ядру, а прослойке
    \item \emph{malloc()} --- неинициализированная память (сколько байт)
    \item \emph{calloc()} --- память инициализированная нулями (сколько объектов хотим)
    \item \emph{realloc()} --- все вместе (может еще перемещать память, 
          так как возвращается не всегда тот указатель, который передали)
    \item Операторы \textbf{new} и \textbf{delete} выражаются через функции C
\end{itemize}

\subsection{Helpers}
\begin{itemize}
    \item \textbf{Valgrind} --- выполняет инструкцию за инструкцией программы, которую ему передали 
          (строит внутри себя модель и отслеживает выделения памяти), долго работает 
          (значительно снижает производительность)
    \item \textbf{Sanitizer (ASAN)} --- инструментируют код, добавляют дополнительные проверки (тоже внутри себя строит модель)
    \item Программы с санитайзером работают не на порядок медленнее, а в 2-3 раза.
\end{itemize}

\subsection{Пример №2}
Когда мы делаем \emph{free()}, память может остаться в userspace.
\code{mem2.c}{C}
Что будет? --- \textbf{Undefined Behavior}

Но ведь ничего не напечаталось
\code{mem2.trace}{C}
На самом деле все напечаталось, просто мы этого не видим

\section{Mapping}

\subsection{Syscalls}
\emph{mmap(), munmap()}
\begin{itemize}
    \item Представьте, что у вас есть файл, и вы заранее не знаете к какой части файла будете обращаться.
    \item Замаппив этот файл в память своего процесса, нужно понимать, что ядро автомитечески не полностью подгружает его в память.
    \item Допустим, есть куча процессов, которые читают свой исполняемый файл\\
          Если бы мы делали это не через маппинг, то каждый раз надо было бы считывать что-то в локальные буфера
    \item С помощью маппинга можно избежать этой проблемы
\end{itemize}

\subsection{Пример №1}
\code{map1.c}{C}
\code{map1.trace}{C}
В выводе \emph{openat()}, так как мы делали не прямой системный вызов

\subsection{Пример №2}
Печать содержимого файла \textbf{/etc/passwd}
\code{map2.c}{C}
\code{map2.trace}{C}

\subsection{Additional}
\begin{itemize}
    \item \emph{pause()} --- системный вызов, останавливает программу, пока она не получит сигнал

    \item Ядро всегда зануляет память, которую отдает

    \item Как работают санитайзеры: выделяют справа и слева блоки памяти, 
          в которых устанавливают флаги и потом чекают на access к ним
\end{itemize}

\subsection{Пример №3}
\shell{man 2 mprotect}
\code{map3.c}{C}
\code{map3.trace}{C}

\shell{man 2 madvise}

\section{Аллокаторы памяти}
Зачем писать свой аллокатор памяти?

Случаи:
\begin{enumerate}
    \item Есть особенность данных, которую хотим использовать
    \item Когда нужно дебажить свой аллокатор
\end{enumerate}
\emph{Slab}-аллокаторы эксплуатируют то, что мы выделяем и освобождаем память одного и того же размера
\code{slab.c}{C}

\section{Безопасность}
\subsection{Meltdown}
\begin{itemize}
    \item Состоит из нескольких этапов
    \item Это атака позволяет читать непривилегированную для процесса память ядра
    \item Использует следующие особенности:
          \begin{itemize}
              \item Спекулятивное выполнение
              \item Утечка данных через сторонний канал
                  \begin{itemize}
                      \item Процессоры имеют кэши
                      \item Оценка времени доступа к массиву позволяет понять, находятся ли данные в кэше
                  \end{itemize}
          \end{itemize}
\end{itemize}

\subsection{ASLR}
Address space layout randomization
\code{aslr.c}{C}
Почему значения почти одинаковые при каждом запуске?

Они рандомизируются (еще один рубеж защиты)

\section{Page Reclaiming}
\todo{presentation}

\section{Page Fault}
\todo{presentation}

\section{Литература}
\begin{itemize}
    \item Understanding the Linux Kernel by Daniel P. Bovet \& Marco Cesati

          (Достаточно хорошо описана архитектура)
    \item Intel 64 and IA-32 Architectures Software Developer's Manual Volume 3

          (Руководство от Intel)
    \item x86 Instruction Set Architecture by Tom Shanley

          (Выжимка руководства от Intel)
    \item What every programmer should know about memory by Ulrich Drepper

          (Очень полезно)
    \item Безопасное программирование на C и C++. Роберт С. Сиакорд

          (Про уязвимости)
\end{itemize}

\section{Домашнее задание №3}
Кусочек \textbf{JIT} компилятора

Цель --- получить знакомство с системными вызывами, используемыми для получения/освобождения
памяти от ядра. Получить представление о том, как может работать \textbf{JIT} компилятор.

Программа должна
\begin{itemize}
    \item Выделить память с помощью \emph{mmap(2)}.
    \item Записать в выделенную память машинный код, соответсвующий какой-либо функции.
    \item Изменить права на выделенную память - чтение и исполнение (\emph{mprotect(2)}).
    \item Вызвать функцию по указателю на выделенную память.
    \item Освободить выделенную память.
\end{itemize}

Что может помочь?
\begin{itemize}
    \item \shell{man objdump}
    \item help disassemble в \textbf{gdb}
\end{itemize}

Extra points
\begin{itemize}
    \item Сильные духом призываются к возможности модификации кода выполняемой функции
          в runtime. 
    \item Например, вы можете получить аргументом вызова вашей программы
          какое-то число и пропатчить машинный код этим числом. Эта часть задания будет
          оцениваться в дополнительные баллы.
\end{itemize}

\end{document}
