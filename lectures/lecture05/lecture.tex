\documentclass[../../lectures.tex]{subfiles}

\begin{document}

\chapter{Линковка и безопасность}

\section{Общее}
\textbf{elf} --- executable linked ... \todo{what?}
Есть еще \textbf{dwarf}

\textbf{Toolchain:}
\begin{enumerate}
    \item Компилятор(Исходный код) = Ассемблерный код --- \shell{cc -S}
    \item Ассемблер(Ассемблерный код) = Объектный код --- \shell{cc -c}
    \item Линковщик(Объектный код) = Исполняемый файл --- \shell{cc .o || ld}
    \item ОС(Исполняемый файл) = Процесс(Текст, данные, стэк)
\end{enumerate}

\section{Пример}
Мы играем роль линковщика
\code{m.c}{C}
\code{func.c}{C}

\section{Ассемблер}
\begin{itemize}
    \item \textbf{as}, часть \textbf{toolchain}
    \item Преобразует ассемблерный код в код машинных инструкций в формате объектного файла
    \item Генерирует объектный код для отдельной \textbf{TU} (Translation Unit)
    \item Не знает никакие адреса символов из других \textbf{TU}
    \item Проставим вместо неизвестных адресов нули --- пускай линковщик разберется
    \item Не знает где в итоговой части памяти будет располагаться код --- пускай будет 0 --- пусть линковщик разберется
    \item Правильные адреса расставит линкер
\end{itemize}

\section{Объектный файл}
\begin{itemize}
    \item Секции
        \begin{itemize}
            \item Секция текста (функции)
            \item Секция данных (переменные)
            \item Секция конструкторов и деструкторов (\textbf{C++})
        \end{itemize}
    \item Таблица символов (карта символов)
        \begin{itemize}
            \item Имя и расположение каждого символа, которые могут быть использованы в других \textbf{TU}
        \end{itemize}
    \item \textbf{Relocations}
        \begin{itemize}
            \item Информация о символах из других \textbf{TU}, которые используется в текущем \textbf{TU}
            \item Используется линковщиком когда известно расположение программы в памяти
        \end{itemize}
    \item Отладочная информация
        \begin{itemize}
            \item Дебаг символы
        \end{itemize}
\end{itemize}

\newpage
\section{Линковщик}
\begin{itemize}
    \item \textbf{ld}, часть \textbf{toolchain}
    \item Склеивает сегменты из отдельных объектных файлов
    \item Оперирует секциями (сегментами) и символами (данные и функции)
    \item Работает согласно скрипту (\shell{ld --verbose})
        \begin{itemize}
            \item Комбинирует отдельные объектные файлы
            \item Понимает как разместить их в памяти
            \item \textbf{fixup, relocation} --- расставляет адреса символов в склееном объектном файле
        \end{itemize}
\end{itemize}
\code{def.h}{C}
\code{main.c}{C}
\code{def.c}{C}
\code{Makefile}{C}
\begin{enumerate}
    \item \shell{cat main.s}
    \item \shell{cat def.s}
    \item \shell{nm main.o}
    \item \shell{nm def.o}
\end{enumerate}
\begin{itemize}
    \item \textbf{T} --- text
    \item \textbf{U} --- undefined (в другой единице трансляции)
    \item \textbf{b} --- bss секция
    \item \textbf{d} --- data
\end{itemize}
\shell{file main} --- Что за файл?\\
\shell{nm main}\\
Все склеиваем и не можем переиспользовать код\\
Тогда на помощь приходят статические библиотеки

\section{Linking vs Loading}
\begin{itemize}
    \item Связанные, но концептуально разные задачи
    \item \textbf{Loading} --- загрузка с диска в память (\emph{runtime})
        \begin{itemize}
            \item Установка правильных режимов защиты памяти для разных секций - \emph{mmap}
        \end{itemize}
    \item \textbf{Linking} --- связываем во что-то большее (\emph{compile time})
        \begin{itemize}
            \item \textbf{Relocation} --- размещение в одной памяти разных объектных файлов
            \item \textbf{Symbol resolution} --- разрешение адресов символов из разных объектных файлов
        \end{itemize}
\end{itemize}

\section{Статическая линковка}
Единожды создаем статическую библиотеку и отдаем ее на линковку
\begin{itemize}
    \item Прочитать размеры всех секций всех объектных файлов, вычислить расположение в памяти
    \item Считать все таблицы символов, создать глобальную таблицу символов в памяти
    \item Считать все секции и все релокейшны, fixup, создать исполняемый файл
    \item Статическая библиотека --- \textbf{lib.a}. Просто \textbf{ar} архив объектных файлов.\\
          \shell{man ar}.
    \item Плюсы:
        \begin{itemize}
            \item Просто, понятно
        \end{itemize}
    \item Минусы:
        \begin{itemize}
            \item Дублирование кода --- \textbf{libc} в каждой программе?
            \item А что если мы хотим загрузить какой-то код во время исполнения?
            \item Уязвимость в библиотеке --- нужно пересобирать все исполняемые файлы?
            \item Адреса известны заранее --- упрощаются атаки на плохой код
        \end{itemize}
\end{itemize}

\section{Динамическая линковка}
\begin{itemize}
    \item Зачем?
        \begin{itemize}
            \item Разделяемые библиотеки --- экономия памяти благодаря отображению страниц
            \item Ненужна пересборка всего для обновления библиотеки
            \item Подгрузка по требованию --- \textbf{implicit} или \textbf{explicit}
        \end{itemize}
    \item Не знаем где разместить код и данные из библиотеки до самого момента
        \begin{itemize}
            \item Наш пример с кодом --- библиотека, какие адреса будут в инструкциях call и mov?
            \item Откладываем линковку до \textbf{runtime}
        \end{itemize}
    \item Две основных идеи
        \begin{itemize}
            \item \textbf{PDC} --- Position Dependent Code --- load-time relocation
            \item \textbf{PIC} --- Position Independent code
        \end{itemize}
    \item Что нужно для ее работы?
        \begin{itemize}
            \item \textbf{runtime linker}
        \end{itemize}
\end{itemize}

\subsection{Relocations}
  * Запомним все адреса и типы обращений к ним, которые необходимо изменить
    - Обращения к коду
    - Обращения к данным
  * Сохраним адреса в метаданных разделяемой библиотеки
  * После размещения библиотеки в памяти - пойдем и пропатчим все адреса на настоящие
  * Плюсы
    - Не требует особой генерации кода
  * Минусы
    - Изменяем код - (W \^ X)
    - Изменяем код - грязные страницы, sharing страниц текста не работает
    - Изменяем код - долго
    - Изменяем код - сложно(разные типа обращений(e.g. mov, call) - требуют разного изменения кода)

\subsection{PIC, данные}
  * Два ключевых момента
    - После того как сегмент текста и данных склеены - знаем смещение из кода до данных - не зависит от реальных адресов
    - Можем получать абсолютный адрес текущего кода

    call TMPLABEL
    TMPLABEL:
      pop %rbx

  * Осталось научиться получать косвенный адрес в абсолютный
  * Добавляем косвенность - Global Offset Table
    - Вместо прямого обращения к данным, обращаемся к таблице по индексу
    - В таблице храним реальные адреса в памяти
    - Картинка
    - Загрузили адрес GOT
    - Из GOT по индексу взяли абсолютный адрес
    - Дальше работаем с абсолютным адресом

\subsection{PIC, текст}
  * Ленивая загрузка
    - Подразумеваем что глобальных переменных сильно меньше чем функций
    - Функций много, используется мало
    - Долго/дорого
  * PLT - Procedure Linkage Table
    - Элемент таблицы - исполняемый код
    - Вызов функции - вызов кода по индексу в таблице
    - Элемент таблицы изменяемый - код изменяемый
    - Ссылается на запись в GOT
    - Запись в GOT ссылается на следующую инструкцию
    - Следующая инструкция выполняет резолвинг символа - функция runtime linker'а
    - Резолвинг символа выполняется и патчит GOT на реальный адрес
    - Вызывает функцию - при следующем выполнении пропускаем дорогой процесс и сразу зовем функцию
  * Минусы
    - Косвенность
    - Использование регистров для непрямых переходов - в x86 GP регистров мало, на один меньше
    - arch/compiler specific


\section{Misc}
  * ABI, благодаря чему все работает
  * mmap
  * Связь с виртуальной памятью и VFS - в памяти данные нужны только в одном экземпляре
  * On demand paging - подгружается только то, что нужно(libicu - ~30MB)

\section{Runtime linker}
  * man 3 dlopen
  * man ld.so
  * На самом деле исполняемые файлы запускаются через runtime linker - /lib64/ld-linux-x86-64.so.2 /bin/ls
  * Полезное/интересное:
    - LD\_PRELOAD
    - LD\_LIBRARY\_PATH
    - RPATH
    - LD\_DEBUG

\section{Безопасность}
  * ASLR
  * Как может работать сигнатурный поиск в антивирусах

\section{Литература}
  * man ld
  * man ld.so
  * man elf
  * man readelf
  * Linkers \& Loaders by John R. Levine
  * How To Write Shared Libraries by Ulrich Drepper
  * Learning Linux Binary Analysis by Ryan "elfmaster" O'Neill

\end{document}
