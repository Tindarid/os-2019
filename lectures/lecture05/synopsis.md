-> Литература <-
================

# Что читать?
  * man ld
  * man ld.so
  * man elf
  * man readelf
  * Linkers & Loaders by John R. Levine
  * How To Write Shared Libraries by Ulrich Drepper
  * Learning Linux Binary Analysis by Ryan "elfmaster" O'Neill

---

-> Сегодня <-
  * Превращение исходного кода в исполняемый объектный файл, toolchain
  * Статическая и динамическая линковка
  * Разделяемые библиотеки и виртуальная память
  * Безопасность

---

-> Превращение <-
=================
  * Toolchain
    - Компилятор(Исходный код) = Ассемблерный код // cc -S
    - Ассемблер(Ассемблерный код) = Объектный код // cc -c
    - Линковщик(Объектный код) = Исполняемый файл // cc .o || ld
    - ОС(Исполняемый файл) = Процесс(Текст, данные, стэк)

---

-> Пример  <-
=============
  * main.c

    int var1;
    extern int var2;
    void func(void);

    int main() {
      var2 = 42;
      func();
    }

  * func.c

    extern int var1;
    int var2;

    void func(void) {
      var1 = var2;
    }

---

-> Ассемблер <-
===============
  * as, часть toolchain
  * Преобразует ассемблерный код в код машинных инструкций в формате объектного файла
  * Генерирует объъектный код для отдельной TU(Translation Unit)
  * Не знает никакие адреса символов из других TU
  * Проставим вместо неизвестных адресов нули - пускай линковщик разберется
  * Не знает где в итоговой части памяти будет располагаться код - пускай будет 0 - путь линковщик разберется

---

-> Объектный файл <-
====================
  * Секции
    - Секция текста
    - Секция данных
    - Секция конструкторов и деструкторов (C++)$
  * Таблица символов
    - Имя и расположение каждого символа, которые могут быть использованы в других TU
  * Релокейшны
    - Информация о символах из других TU, которые используется в текущем TU
    - Используется линковщиком когда известно расположение программы в памяти
  * Отладочная информация
    - Дебаг символы

---

-> Линковщик <-
===============
  * ld, часть toolchain
  * Склеивает сегменты из отдельных объектных файлов
  * Оперирует секциями(сегментами) и символами(данные и функции)
  * Работает согласно скрипту(ld --verbose)
    - Комбинирует отдельные объектные файлы
    - Понимает как разместить их в памяти
    - fixup, relocation - расставляет адреса символов в склееном объектном файле

---

-> Linking vs Loading <-
========================
  * Связанные, но концептуально разные задачи
  * Loading
    - Загрузка с диска в память
    - Установка правильных режимов защиты памяти для разных секций - mmap
  * Linking
    - Relocation - размещение в одной памяти разных объектных файлов
    - Symbol resolution - разрешение адресов символов из разных объектных файлов

---

>- Статическая линковка <-
==========================
  * Прочитать размеры всех секций всех объектных файлов, вычислить расположение в памяти
  * Считать все таблицы символов, создать глобальную таблицу символов в памяти
  * Считать все секции и все релокейшны, fixup, создать исполняемый файл
  * Статическая библиотека - lib.a. Просто ar архив объектных файлов. man ar.
  * Плюсы:
    - Просто, понятно
  * Минусы:
      - Дублирование кода - libc в каждой программе?
      - А что если мы хотим загрузить какой-то код во время исполнения?
      - Уязвимость в библиотеке - нужно пересобирать все исполняемые файлы?
      - Адреса известны заранее - упрощаются атаки на плохой код

---

>- Динамическая линковка <-
===========================
  * Зачем?
    - Разделяемые библиотеки - экономия памяти благодаря отображению страниц
    - Ненужна пересборка всего для обновления библиотеки
    - Подгрузка по требованию - implicit или explicit
  * Не знаем где разместить код и данные из библиотеки до самого момента
    - Наш пример с кодом - библиотека, какие адреса будут в инструкциях call и mov?
  * Две основных идеи
    - PDC - Position Dependenet Code - load-time relocation
    - PIC - Position Independent code
  * Что нужно для ее работы?
    - runtime linker

---

-> Динамическая линковка relocations <-
=============================
  * Запомним все адреса и типы обращений к ним, которые необходимо изменить
    - Обращения к коду
    - Обращения к данным
  * Сохраним адреса в метаданных разделяемой библиотеки
  * После размещения библиотеки в памяти - пойдем и пропатчим все адреса на настоящие
  * Плюсы
    - Не требует особой генерации кода
  * Минусы
    - Изменяем код - (W ^ X)
    - Изменяем код - грязные страницы, sharing страниц текста не работает
    - Изменяем код - долго
    - Изменяем код - сложно(разные типа обращений(e.g. mov, call) - требуют разного изменения кода)

---

-> Динамическая линковка и PIC, данные <-
=========================================
  * Два ключевых момента
    - После того как сегмент текста и данных склеены - знаем смещение из кода до данных - не зависит от реальных адресов
    - Можем получать абсолютный адрес текущего кода

    call TMPLABEL
    TMPLABEL:
      pop %rbx

  * Осталось научиться получать косвенный адрес в абсолютный
  * Добавляем косвенность - Global Offset Table
    - Вместо прямого обращения к данным, обращаемся к таблице по индексу
    - В таблице храним реальные адреса в памяти
    - Картинка
    - Загрузили адрес GOT
    - Из GOT по индексу взяли абсолютный адрес
    - Дальше работаем с абсолютным адресом

---

-> Динамическая загрука и PIC, текст <-
=======================================
  * Ленивая загрузка
    - Подразумеваем что глобальных переменных сильно меньше чем функций
    - Функций много, используется мало
    - Долго/дорого
  * PLT - Procedure Linkage Table
    - Элемент таблицы - исполняемый код
    - Вызов функции - вызов кода по индексу в таблице
    - Элемент таблицы изменяемый - код изменяемый
    - Ссылается на запись в GOT
    - Запись в GOT ссылается на следующую инструкцию
    - Следующая инструкция выполняет резолвинг символа - функция runtime linker'а
    - Резолвинг символа выполняется и патчит GOT на реальный адрес
    - Вызывает функцию - при следующем выполнении пропускаем дорогой процесс и сразу зовем функцию
  * Минусы
    - Косвенность
    - Использование регистров для непрямых переходов - в x86 GP регистров мало, на один меньше
    - arch/compiler specific

---

-> Misc <-
==========
  * ABI, благодаря чему все работает
  * mmap
  * Связь с виртуальной памятью и VFS - в памяти данные нужны только в одном экземпляре
  * On demand paging - подгружается только то, что нужно(libicu - ~30MB)
---

-> runtime linker <-
====================
  * man 3 dlopen
  * man ld.so
  * На самом деле исполняемые файлы запускаются через runtime linker - /lib64/ld-linux-x86-64.so.2 /bin/ls
  * Полезное/интересное:
    - LD_PRELOAD
    - LD_LIBRARY_PATH
    - RPATH
    - LD_DEBUG
---

-> Б - безопасность <-
======================
  * ASLR
  * Как может работать сигнатурный поиск в антивирусах
---
