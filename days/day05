Тема 4 лекции ? : Виртуальная память

Уязвимость Meltdown

Литература:
1. достаточно хорошо описана архитектура
2. руководство интела
3. --- выжимка 2.
4. What every ... --- очень полезно
5. Уязвимости

Прерывания и исключения

Процессор с памятью не могут быть жить в вакууме (без ОС)
Простыми словами: иногда процессор не знает что ему делать в конкретной ситуации,
так как не знает контекста исполнения, тогда он просит помощи у внешней среды (чаще всего ОС)
\emph{Interrupt Deriving Architecture} --- есть таблица, каждой ячейке которой соотвествует какая-либо
исключительная ситуация(например, поделить на нуль) и функция ее разрешающая.
IDTR --- регистр, в котором хранится адрес Interrupt Descriptor Table (глобальный)
В некоторых архитектурах находится по фиксированному адресу (например, x86 --- защищенный режим)
Проще говоря \textbf{callbacks}

2 подход --- \emph{Polling} (есть управляющий код, который периодически опрашивает устройство на предмет того,
что нужно обработать; процессор выставляет флаг --- "нуждаюсь в обработке"). Пример --- сетевая карта

У каждого подхода свои плюсы и минусы

\textbf{cr2} --- контрольный регистр, считывается функцией \emph{do_page_fault} 
(которая занимается обработкой \textbf{page fault})


Память

Хочется чтобы каждый процесс был защищен от любого другого

Проблемы памяти:
1. Памяти мало, она дорогая
2. Памяти мало, программ много, как договориться?
    Закон Парето - 80% обращений к 20% памяти в среднем у пользовательской программы
    Может тогда выгружать неиспользуемую память на диск?
    Может еще переиспользовать память? --- например сегмент \textbf{text} у \textbf{Chrome}
3. Памяти мало, программ много, как защититься?
    Неплохо было бы выложить в read-only какую-то память (сегмент \textbf{text} --- \emph{const}-переменные)
    Переполнение буфера у стека
    func b() {
        a();
    }
    func a() {
        char A[100];
        cin >> ; // 132 байта
        // Начали писать вверх и переписали адрес возврата (так как стек растет вниз, а адреса массива вверх)
        // Когда делаем RET, вернемся по испорченному адресу
    }
    Способ защиты --- память, которая может записываться не может выполняться
    Канарейка на стеке --- проверяем значение переменной "канарейка", которую добавили после адреса возврата

    Хотим чтобы память ядра была недоступна пользователям

Как можно это все сделать?

Подход 1 --- Досегментная организация
Попробуем изменять адреса в программе перед запуском
    Выделяем необходимое количество памяти
    Заменяем все адреса с учетом выделенной памяти
    Relocations --- механизм \todo{?}
    Проще говоря патчинг (но не всех страниц)
Проблемы
    А что если нужно переместить программу в памяти?
    А что если не найдем подходящего куска памяти?
    Нет защиты

Подход 2 --- Сегментная организация
Введем косвенность
    Программы работают с виртуальными адресами
    Виртаульный адрес = смещение относительно сегмента
    Сегмент = база + размер
    Физический адрес = база сегмента + виртаульный адрес

    Картиночка (segment-translation.png)
    MMU --- memory managment unit (железная штука)

    Еще картиночка (segmentation-hardware.jpg)

    Презентация ...

    Пусть у нас будет 3 разных сегмента памяти (CS, DS, и SS)

Переключение контекста сводится к замене сегментов

Все классно, но внутренняя и внешняя фрагментация --- основная проблема
    
Подход 3 --- Страничная организация
В большинстве случаев размер страницы - 4 килобайта
Презентация ...
У виртуального и физического адреса будут одинаковые --- alignment, offset
Нам нужно хранить маппинг только для старших 20 бит.
Картинка --- paging-addressing.png

Чуть больше про реальность --- Страничная организация в x86
Таблца страниц - слишком много места. Нужна иерархия
Размер иерархии - tradeoff между overhead на размер служебной информаци и скоростью трансляции
Иерархия:
    page directory = 1024 PDE (page directory entry)
        PDE содержит адрес PT (page table)
    PT - 1024 PIE (page table entry)
        PTE содержит физический адрес страницы
        PT --- 4 MB of Virtual Memory
Время доступа - дороже, в умных книжах пишут, что виртуальная память замедлила программы на 10-30%
Картиночка --- page-address-extenseions.png
Презентация ...

MMU 
Презентация ...
Картинка(TLB) --- paging-hardware.jpg

Переключение контекста
Презентация ...

Примеры использования
Подкачка по требованию
    Пусть у вас есть фильм. Давайте читать этот файл используя
    окно считывания. Прикольно. Но можем замаппить файл в память 
    и читать его.

    Каждый раз когда читаем еще незагруженную страницу, page fault,
    далее ядро подгружает страницу.

    Еще пример --- chrome --help (нам незачем инициализировать всю работу приложения)

    Ядро достаточно оптимально все это делает.

Copy on write
    copyonwrite.cpp

    Какое значение x будет в parent и в child?

    Немного по-другому
    copyonwrite2.cpp

    Одинаковые адреса, значение разное (child --- 43, parent --- 42)

    При создании процесса --- ничего не делаем

    За всей этой истории стоит MMU

Swap
    Скидывание на диск холодной data
    MMU ходит по кругу и проверяет использование страниц
Презентация
