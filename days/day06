Продолжение лекции про виртуальную память

\section{Выделение памяти}

\code{mem1.c}{C}
\shell{strace -f ./mem.out}
\code{tracemap1}{C}

Нет никакого выделения памяти через \emph{malloc} (потому что это не системный вызов)
\shell{man 2 brk, sbrk} --- явное увеличение/уменьшение кучи
Для того же самого со стеком системных вызовов нет (только ассемблерные инструкции)
\emph{malloc/calloc/realloc} через прослойку выделяют себе блок памяти, режут его на куски и выдают клиенту-программисту
\emph{free()} --- отдает блок памяти не ядру, а прослойке
\emph{malloc()} --- неинициализированная память (сколько байт)
\emph{calloc()} --- память инициализированная нулями (сколько объектов хотим)
\emph{realloc()} --- все вместе (может еще перемещать память, так как возвращается не всегда тот указатель, который передали)
Операторы \textbf{new} и \textbf{delete} выражаются через функции C

\textbf{Valgrind} --- выполняет инструкцию за инструкцией программы, которую ему передали (строит внутри себя модель и отслеживает
выделения памяти), долго работает (значительно снижает производительность)
\textbf{Sanitizer (ASAN)} --- инструментируют код, добавляют дополнительные проверки (тоже внутри себя строит модель)
Программы с санитайзером работают не на порядок медленнее, а в 2-3 раза.

Когда мы делаем free, память может остаться в userspace.
\code{mem2.c}{C}
Что будет?
\textbf{Undefined Behavior}
Ничего не напечаталось
На самом деле все напечаталось, просто мы этого не видим
strace

\section{Mapping}

\emph{mmap(), munmap()}
Представьте, что у вас есть файл, и вы заранее не знаете к какой части файла будете обращаться.
Замаппив этот файл в память своего процесса, нужно понимать, что ядро автомитечески не полностью подгружает его в память.
Картинка(mappingannotated.ppt)
Если есть куча процессов, которые читают свой исполняемый файл
Если бы мы делали это не через маппинг, то каждый раз надо было бы считывать что-то в локальные буфера
С помощью маппинга можно избежать этой проблемы

\code{map1.c}{C}
strace
В выводе \emph{openat}, так как мы делали не прямой системный вызов

\code{map2.c}{C}
strace
Печать содержимого файла /etc/passwd

\emph{pause()} --- системный вызов, останавливает программу, пока она не получит сигнал

Еще картинка из презентации из интернета
Ядро всегда зануляет память, которую отдает

Как работают санитайзеры --- выделяют справа и слева блоки памяти, в которых устанавливают флаги (?) и потом чекают на access к ним?

ДЗ 3
В двух словах: toy jit compilator

\shell{man 2 mprotect}
\code{map3.c}{C}

\shell{man 2 madvise}

\section{Безопасность}
\subsection{Meltdown}
Атака состоит из нескольких этапов
Это атака позволяет читать непривилегированную для процесса память ядра
Использует следующие особенности:
Спекулятивное выполнение
Утечка данных через сторонний канал
    Процессоры имеют кэши
    Оценка времени доступа к массиву позволяет понять, находятся ли данные в кэше

\section{ASLR}
Address space layout randomization
\code{mem3.c}{C}
Почему значения почти одинаковые при каждом запуске?
Еще один рубеж защиты

\section{Аллокаторы памяти}
Зачем писать свой аллокатор памяти?
1 случай: Есть особенность данных, которую хотим использовать
2 случай: Когда нужно дебажить свой аллокатор
Slab-аллокаторы эксплуатируют то, что мы выделяем и освобождаем память одного и того же размера
\code{slab.c}{C}
