Старое:
fork() - для того чтобы заместить процесс?
wait(pid) - ждем процесс
exit() - завершаемся
SIGKILL - принудительное завершение другого процесса (# kill)

У каждого pid есть parentpid (ppid)
# ps - позволяет посмотреть специфичные атрибуты процесса
Процесс init(pid 0) создается ядром, выступает родителем для большинства процессов, созданных в системе
Тогда можно построить дерево процессов (# pstree)

Процесс делает fork(). 2 случая:
1. Процесс не делает wait(childpid)
Зомби-процесс - когда дочерний процесс завершается быстрее чем вы сделаете wait
2. Процесс завершается, что происходит с дочерним процессом?
Сирота(orphan) - процесс у которого умер родитель, ему назначется родителем процесс с pid 1(время от времени делает wait() и освобождается от детей)
pid - переиспользуемая штука (таблица процессов)

Coding convention - как вызываются syscall (man syscall)
Код:
syscall.h
#ifndef SYSCALL_H
#define SYSCALL_H

void IFMO_syscall();

#endif

main.c
#include "syscall.h"

int main(...) {
    IFMO_syscal();
}

syscall.s
.data

.text
.global IFMO_syscall

IFMO_syscall:
    movq $1, %rax
    movq $1, %rdi
    movq $0, %rsi
    movq $555, %rdx
    syscall
    ret

Вызываем write()
Просим ядро записать 555 байт начинающихся по адресу 0 в файловый дескриптор #1
#1 stdout
#2 stdin
#3 stderr
Ничего не происходит?
Утилита # strace - трассировка процесса(подсматриваем за процессом, последовательность syscall с аргументами и кодами возврата)
Write(1, NULL, 555) возвращает -1 EFAULT (Bad address)
Если syscall ничего не возвращает, то пишется "?" вместо возвращаемого значения
man errno - ошибки
Если делаем fork() - проверяем код возврата
strerror - возвращает строковое описание кода ошибки (char* strerror(int errnum);)

thread_local - решение проблемы: переменная с ошибкой - общая для каждого потока?

До main() и всего-всего происходит куча всего (munmap, mprotect, mmap, access) - размещение процесса в памяти и т.д.
Программа не всегда завершается по языковым гарантиям (деструкторы)

Диаграмма времени жизни процесса и взаимодействия с ОС:
.png

Дз1: написать shell-интерпретатор
Читать из stdin 
В дочернем процессе execve()
В родительском процессе wait()
Сдавать через гитхаб

Переключение контекста(иллюзия многозадачности):
.png

# ptrace - позволяет одному процессу следить за другим (используется, например, в gdb)



Начало лекции 3
Файловые системы:
# find - поиск

HDD
.png
Обороты в минуту - 5400, 7200, 10000, ...
1 / Oбороты / 2 - ~минимальное время доступа (случайное чтение) ?
В мире Unix не существует дефрагментации (ОС должна сама заботиться)
Время отказа (MTBF - min time before failure?) - условное количество циклов наработки до отказа
На server - сутки, desktop - часы (разница в 3 раза примерно, если одно и то же число циклов)
Плюсы: стоимость, объем
Минусы: время доступа, надежность

EOPS - ?
seek - рандомное чтение (512 байт)
SATA и NVME - протоколы для дисков
NVME - новомодная штука для SSD

Общие соображения:
Презентация

Интересные числа(должен знать каждый программист):
Презентация(от самого быстрого до самого медленного)

Выводы для HDD:
Презентация

structure packaging (allignment):
struct hole {
    uint64_t a;
    uint32_t b;
    uint64_t c;
    uint32_t d;
}
Сколько будет занимать? (32 байта на x86_64)
b и d будут выравнены по MAX_ALLIGNMENT
Решение(очевидное):
struct hole {
    uint64_t a;
    uint32_t b;
    uint32_t d;
    uint64_t c;
}
Сколько будет занимать? (24 байта на x86_64)


Презентация из ИНТЕРНЕТА(slideplayer.com/slide/5209336)
SLIDE 6: Алгоритмы элеватора обрабатывают последовательности запросов к диску (переупорядочивают их)
SLIDE 7: FCFS (FIFO) - самый простой и медленный
SLIDE 8-9: SSTF - сортировка (очередной запрос определяется наименьшим временем seek)
SLIDE 10-...: Различные способы

Файл
Абстракция для данных
Последовательность байт
Формат не определен
Unix - все есть файл (абстракция-интерфейс внутри ядра)
Типы: Презентация

Директории
Содержит имена находящихся в нем файлов
. - ссылка на текущую
.. - ссылка на родителя
# cd, # pwd
Формирование дерева: # ls ?
filename vs pathname: # realpath
Права - "просто числа"
    # view /etc/passwd
    # view /etc/group
    # id - показывает идентификаторы того, кто ее вызывал
    execute - search
    read - directory listing
    write - changing directory
    Темные директории (переход в директорию внутри директории, для который ты не можешь посмотреть все файлы)
    # chmod - меняет права доступа
sticky bit
    Изменение поведения при создании нового файла
    /tmp
    Создаешь директорию со sticky bit и все, кто создают файлы в этой директории имеют на них права

Иерархия:
Презентация

Есть корень и есть узлы, в которые можно монтировать другие файловые системы (часть из них виртуальная)
# mount
Для / обычно используется ext4 (использует журналирование)
Для /boot может использоваться ext2 - так как это более проверено временем (на Ubuntu)
Файловая система для узла - это не константа, ее можно менять
# df - h, # du -hs

Inode
Презентация
Директория задает mapping имени файла в его inode
# ln 
Hardlink - существует в рамках одной файловой системы
Softlink(symlink) - бит l
# stat - информация о файле
Atime - время последнего доступа
Mtime - изменение мета-информации
Ctime - изменение содержимого файла

