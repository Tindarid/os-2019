\chapter{IPC}

\todo{Ссылка на презентацию}

\section{Литература}
The Linux Programming Interface (практически все описано)

\section{Общее}
Есть много разных \textbf{IPC} --- Inter Process Communication
Примеры: \textbf{pipes in shell}, \textbf{sockets}, \textbf{System V shared memory},
\textbf{signals}, \textbf{mutexes}
\todo{Куча примеров из презентации}

\textbf{IPC} дает какой-то способ взаимодействия
\textbf{IPC} нужно выбирать с умом, зная требования к взаимодействию

Демоны (\textbf{daemons}) --- служебные процессы, которые долго живут 
и не перезагружаются (обслуживают что-то)

\section{Картинки}
\todo{Две картинки-схемы}

\section{Сигналы}
Сигналы характеризуются числом
\textbf{SIGSEGV} --- segmentation violation
\textbf{SIGBUS} --- генереируются в связи с проблемами маппинга виртуальной памяти на диск
\textbf{SIGINT} --- interrupt (Ctrl + C)
\textbf{SIGILL} --- illegal instruction
\textbf{SIGUSR1, SIGUSR2} --- отдаются на использование программисту
\textbf{SIGSTOP} --- процесс перестает шедулироваться (грубо говоря замораживается)
\textbf{SIGCONT} --- процесс начинает шедулироваться?
\shell{kill -SIGSTOP [number of proccess]}
Сигналы выставляются процессу

#include <assert.h>

int main(int argc, const char *argv[]) {
    assert(0);
}
Что произошло?

У сигнала может быть три разных поведения: игнорирование, дефолтное, свой обработчик
\textbf{SIGKILL} и \textbf{SIGSTOP} --- нельзя ни перехватить, ни игнорировать
\textbf{SIGTERM} --- попросить процесс завершиться

Как послать сигнал самому себе?
#include <signal.h>

int main(int argc, const char *argv[]) {
    raise(SIGNAL);
}

Пишем свой обработчик сигнала
#include <signal.h>
#include <unistd.h>

static void sigint_handler(int signo) {
    printf("SIGINT caught\n");
}

int main() {
    signal(SIGINT, sigint_handler);

    for(;;) {
        sleep(1);
    }
}
Нажимаем Ctrl + C, ловим сигнал

#include <signal.h>
#include <unistd.h>

static void sigint_handler(int signo) {
    printf("SIGINT caught\n");

}

int main() {
    signal(SIGINT, sigint_handler);

    for(;;) {
        sleep(10000);
        printf("hm\n");
    }
}
Генерация сигнала прерывает функцию \emph{sleep()}
Сигнал обрабатывается по границе выполняемой инструкции

#include <signal.h>
#include <unistd.h>

static unsigned counter = 0;

static void sigint_handler(int signo) {
    counter += 100500;
    printf("SIGINT caught\n");

}

static void non_reentrant_func() {
    for (;;) {
        const unsigned prev_counter = counter;
        ++counter;
        assert(prev_counter + 1 == counter);
    }
}

int main() {
    signal(SIGINT, sigint_handler);
    non_reentrant_func();
}
Мы не имеем права звать из обработчика сигналов нереентерабельные функции (\emph{malloc()}, \emph{printf()}, \dots)

#include <signal.h>
#include <unistd.h>

static sig_atomic_t sigint_flag;

static void sigint_handler(int signo) {
    sigint_flag = 1;
}

int main() {
    signal(SIGINT, sigint_handler);

    for(;;) {
        if (sigint_flag) {
            printf("SIGINT caught\n");
            sigint_flag = 0;
        }
        sleep(1);
    }
}
sig_atomic_t --- define для ?


#include <signal.h>
#include <unistd.h>

static sig_atomic_t sigint_flag;

static void sigint_handler(int signo) {
    if (signo == SIGINT) {
        sigint_flag = 1;
        printf("SIGINT caught\n");
        raise(SIGUSR1);
        printf("SIGUSR1 sent\n");
    } else {
        assert(signo == SIGUSR1);
        printf("SIGUSR1 caught\n");
    }
}

int main() {
    signal(SIGINT, sig_handler);
    signal(SIGUSR1, sig_handler);

    for(;;) {
        if (sigint_flag) {
            printf("SIGINT caught\n");
            sigint_flag = 0;
        }
        sleep(1);
    }
}
Если сигнал возникнет в обработчике сигнала, то он обработается

Можно взять обработчик сигнала для \textbf{SIGIGN}, и поставить его также на обработку какого-нибудь другого

У интерфейса сигналов много проблем, поэтому появился advanced интерфейс 
\shell{man sigaction}
Можно доставать из него информацию о проблеме (например, для \textbf{SIGSEGV} --- адрес памяти, которая защищена)

Гадание по \textbf{cr2} как в Матрице


(Очень сложный пример c ассемблером)


Если сигнал возник во время системного вызова, то он возвращается с кодом ошибки \textbf{EINTR}
\textbf{SA_RESTART} --- чтобы продолжить


\section{Pipes}
Примитив \textbf{IPC}
Данные на одном конце получаются ровно в том порядке, в котором они передаются с другого конца
\shell{man pipe}
\emph{pipe()} --- системный вызов для создания
\shell{man dup}
\emph{dup} --- создание копии файлового дескриптора
\textbf{pipe} == byte stream buffer in kernel

\section{FIFO}
Именованный \textbf{pipe}
\shell{mkfifo}
